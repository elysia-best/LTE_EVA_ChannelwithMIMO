% Machine Learning Based Channel Estimation for
% 5G NR-V2V Communications: Sparse Bayesian
% Learning and Gaussian Progress Regression
% Method used: BEM, SPL and GPR

%%%%%%%%%%%%%%%%%%%%%%初始条件和信号生成%%%%%%%%%%%%%%%%%%%%%%%
num_bit = 128000;      % 总比特数
M = 4;                 % QPSK 调制阶数 (4-PSK)
k = log2(M);           % 每符号携带比特数 = 2
Rb = 20*(10^4);        % 比特率 20 kbps
Rs = 2*Rb / k;         % 符号率 = 20k * 2 / 2 = 20 ksym/s
Tb = 1/Rb; Ts = 1/Rs;  % 比特/符号周期
rng('default'); rng(67); % 固定随机种子，确保可复现
msg = randi([0,1],1,num_bit); % 生成随机二进制比特流
SNR_awgn = 20;         % AWGN 信噪比 = 20 dB 

%%%%%%%%%%%QPSK调制%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
msg = transpose(msg);
msg_syb = transpose(reshape(msg, size(msg, 2)*k, size(msg, 1)/k)); % 2比特一组
msg_de = bi2de(msg_syb); % 二进制转十进制 [0,1,2,3]

grayencode = bitxor(0:M-1, floor((0:M-1)/2)); % [0,1,3,2]
msg_gry_enc = grayencode(msg_de+1); % 格雷编码映射
msg_qpsk = pskmod(msg_gry_enc,M, pi/4); % QPSK 调制，相位偏移 π/4, 长度为 num_bit/2 的复数符号序列

%%%%%%%%%%添加导频%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
pilotfrequency = 50;     %导频间隔,每 50 个数据符号插入 1 个导频
pilot_num = fix(length(msg_qpsk)/pilotfrequency);    %导频数量, fix - 向零舍入
% 用 rest_num2 补零，使总长度能被 (pilotfrequency + 1) 整除
rest_num2 = pilotfrequency*(pilot_num + 1) - length(msg_qpsk);  %导频补零
pilot_num =pilot_num + 1;
msg_qpsk(1, pilot_num * pilotfrequency) = 0;    %补0
% 重构为矩阵：每行 pilotfrequency + 1 (51) 个元素（50 数据 + 1 导频）
% msg_pilot's shape is length(msg_qpsk)/pilotfrequency),pilotfrequency
msg_pilot = transpose(reshape(msg_qpsk, pilotfrequency,length(msg_qpsk)/pilotfrequency));  % trick, 添加导频方便而已
msg_pilot_aft = zeros(length(msg_qpsk)/pilotfrequency,pilotfrequency+1);    % initialize matrix for speedup
for i = 1:length(msg_qpsk)/pilotfrequency
   msg_pilot_aft(i,:) = [1, msg_pilot(i,:)] ;   %插入导频
end
% 最终序列：[导频, 数据, 数据, ..., 导频, 数据, ...]，长度 = 64,000 + 1280 + (50 + 1)= 65,331
% 50 + 1 are introduced by adding zero
msg_pilot_aft_casd = reshape(transpose(msg_pilot_aft), 1, numel(msg_pilot_aft));     %转成行

%%%%%%%%%串并变换%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
num_carrier = 1024;    % 子载波数
len_cp = 106;          % 循环前缀长度（约 106/20000 ≈ 5.3 μs，合理）
group_prl = fix(length(msg_pilot_aft_casd)/num_carrier); % 分组数
rest_num3 = num_carrier*(group_prl + 1) - length(msg_pilot_aft_casd);
group_prl = group_prl + 1; % TODO: Here maybe problematic, when it was divided with no remains , is it really needed to add one?
msg_pilot_aft_casd(1, num_carrier * group_prl) = 1; % 再次补1（为何？）

msg_prl = transpose(reshape(msg_pilot_aft_casd, num_carrier, group_prl)); % 串并变换

%%%%%%%%%%%%OFDM%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%% IFFT + 加循环前缀（CP）→ 时域 OFDM 信号 %%%%%%%%
N = sqrt(num_carrier); % 归一化因子（用于能量归一）
msg_idft = zeros(group_prl, num_carrier);
msg_ofdm = zeros(group_prl, num_carrier+len_cp);
for j = 1 : group_prl
   msg_idft(j,:) = ifft(msg_prl(j,:))/N;    % IFFT，频域→时域
   cp(j,:) = msg_idft(j,num_carrier-len_cp+1:num_carrier); % 取最后 len_cp 个点
   msg_ofdm(j,:) = cat(2,cp(j,:),msg_idft(j,:)); % 加 CP：[CP][Data]
end

%%%%%% Rayleigh_chan + EVA PDP %%%%%%%%
rayleigh_chan = comm.RayleighChannel(...
       'SampleRate', Rs,...
       'PathDelays', [0,30,150,310,370,710,1090,1730,2510]*1e-9,...
       'AveragePathGains',[0,-1.5,-1.4,-3.6,-0.6,-9.1,-7.0,-12.0,-16.9],...
       'NormalizePathGains',true,...
       'MaximumDopplerShift',100,...
       'RandomStream', 'mt19937ar with seed',...
       'Seed', 1540,...
       'PathGainsOutputPort',true);%rayleigh channel with EVA PDP

%%%%%% Pass the Channel %%%%%%%%
msg_ray0 = zeros(num_carrier+len_cp, group_prl);
msg_ray = zeros(group_prl, num_carrier+len_cp);
msg_awgn = zeros(group_prl, num_carrier+len_cp);
for j = 1 : group_prl
    %signal after rayleigh channel   
    [msg_ray0(:,j),PathGains1] = step(rayleigh_chan, transpose(msg_ofdm(j,:)));
    msg_ray(j,:) = transpose(msg_ray0(:,j));
    %%AWGN_chan%
    msg_awgn(j,:) = awgn(msg_ray(j,:),SNR_awgn,'measured',19980611);    %after passing rayleigh
end

%%%%% Wipe off CP and do FFT %%%%%%%%
msg_nocp = zeros(group_prl, num_carrier);
msg_fft = zeros(group_prl, num_carrier);
for j = 1 : group_prl
    msg_nocp(j,:) = msg_awgn(j,len_cp+1:num_carrier+len_cp); %wipe off cp
    msg_fft(j,:) = N*fft(msg_nocp(j,:));                     %dft
end

%%%%%%%%%%%%%%%%%%并串变换%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
msg_casd = reshape(transpose(msg_fft),1,numel(msg_fft));

%%%%%%%%%%%%%%%%%信道估计%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% LS Method
PLoc_1 = 1: (pilotfrequency+1) :length(msg_pilot_aft_casd); % 导频原始位置
inserted_pilots = ones(1, numel(PLoc_1)); % The inserted pilots are all 1
h_ls = LS_CE(msg_casd, inserted_pilots, PLoc_1, length(msg_casd), 50, 'linear');

yp = msg_casd(PLoc_1); % 接收端测得的导频值（含信道影响）
h_est = interp1(PLoc_1, yp, 1:msg_casd_len); % 线性插值，估计所有子载波信道
h_est(msg_casd_len - rest_num + 1 :msg_casd_len) = []; % 删除末尾补零
PLoc = 1: (pilotfrequency+1) :length(h_est); 
DLoc = setxor(1:length(h_est), PLoc);      % 数据位置

msg_casd(msg_casd_len - rest_num2 +1 : msg_casd_len) = []; % 删除原始补零
msg_casd = msg_casd(DLoc); % 只保留数据子载波
h_ray = h_est(DLoc);       % 对应的数据子载波信道估计值